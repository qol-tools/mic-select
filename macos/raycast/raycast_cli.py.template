#!/usr/bin/env python3
import argparse
import sys
import logging
import json
from pathlib import Path
from typing import Dict, Any

_script_dir = Path(__file__).parent
_project_root = _script_dir.parent.parent
if str(_project_root) not in sys.path:
    sys.path.insert(0, str(_project_root))

from lib.config import Config
from lib.dependency_injection.container import Container

logging.basicConfig(
    level=logging.WARNING,
    format="%(levelname)s: %(message)s"
)

logger = logging.getLogger(__name__)


def output_json(data: Dict[str, Any], exit_code: int = 0) -> None:
    """Output JSON data and exit."""
    try:
        json.dump(data, sys.stdout, indent=2)
        sys.stdout.write("\n")
        sys.exit(exit_code)
    except (TypeError, ValueError) as e:
        output_error(f"Failed to serialize JSON: {e}", 1)


def output_error(message: str, exit_code: int = 1) -> None:
    """Output error as JSON and exit."""
    output_json({"error": message}, exit_code)


def list_command(container: Container, query: str = "", limit: int = 10) -> None:
    """Execute list command."""
    try:
        use_case = container.list_sources_use_case()
        sources = use_case.execute(query=query, limit=limit)

        sources_data = [
            {"name": source.name, "index": source.index}
            for source in sources.sources
        ]

        output_json({"sources": sources_data})
    except ValueError as e:
        output_error(str(e), 1)
    except Exception as e:
        logger.error(f"Error in list command: {e}", exc_info=True)
        output_error(f"Failed to list sources: {e}", 1)


def switch_command(container: Container, name: str) -> None:
    """Execute switch command."""
    try:
        if not name or not name.strip():
            output_error("Source name cannot be empty", 1)
            return

        use_case = container.switch_source_use_case()
        use_case.execute(name.strip())

        output_json({
            "success": True,
            "message": f"Switched to audio source: {name.strip()}"
        })
    except ValueError as e:
        output_error(str(e), 1)
    except RuntimeError as e:
        output_error(str(e), 1)
    except Exception as e:
        logger.error(f"Error in switch command: {e}", exc_info=True)
        output_error(f"Failed to switch source: {e}", 1)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Select Microphone - CLI for Raycast",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    list_parser = subparsers.add_parser("list", help="List audio sources")
    list_parser.add_argument(
        "--query",
        type=str,
        default="",
        help="Filter sources by query string"
    )
    list_parser.add_argument(
        "--limit",
        type=int,
        default=10,
        help="Maximum number of sources to return (default: 10)"
    )

    switch_parser = subparsers.add_parser("switch", help="Switch audio source")
    switch_parser.add_argument(
        "--name",
        type=str,
        required=True,
        help="Name of the audio source to switch to"
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        output_error("No command specified", 1)
        return

    try:
        container = Container()

        if args.command == "list":
            list_command(container, query=args.query, limit=args.limit)
        elif args.command == "switch":
            switch_command(container, name=args.name)
        else:
            output_error(f"Unknown command: {args.command}", 1)
    except KeyboardInterrupt:
        output_error("Interrupted by user", 130)
    except Exception as e:
        logging.error(f"Unexpected error: {e}", exc_info=True)
        output_error(f"Unexpected error: {e}", 1)


if __name__ == "__main__":
    main()
